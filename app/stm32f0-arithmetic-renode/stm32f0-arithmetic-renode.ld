/*
stm32f0-arithmetic-renode.ld
    includes stm32f051.ld
        MEMORY
            defines flash_region
            defines sram_region
        SECTIONS
            defines MM peripherals: apb, ahb1, ahb2
            includes armv6-m.sections.ld for 0xE0000000 (Cortex-M0 peripherals)
            includes stm32f0.sections.ld for vectors, text, rodata, bss etc.
*/

ENTRY(resetHandler)

MEMORY {
	/* Main flash memory. */
	flash_region (RX) : ORIGIN = 0x08000000, LENGTH = 64K /* for STM32F051x8 */

	/* 0x1FFF EC00 - 0x1FFF F7FF 3 KBSystem memory */
	/* 0x1FFF F800 - 0x1FFF FBFF 1 KBOption bytes */

	/* Main system SRAM. */
	sram_region (WXA) : ORIGIN = 0x20000000, LENGTH = 8K

	stm32f0_periph_region (WR) : ORIGIN = 0x40000000, LENGTH = 0x08001800

	cm0_periph_region (WR) : ORIGIN = 0xE0000000, LENGTH = 0x00100000 
}

/* check this: https://developer.arm.com/documentation/107976/21-1-1/Map-code-and-data-to-your-target-device/Linker-scripts/Linker-script-PHDRS-command */

/* Program header table */
PHDRS {
	text_segment PT_LOAD;
	bss_segment PT_NULL;
	stack_segment PT_NULL;
	data_segment PT_LOAD;
	cm0_periph_segment PT_NULL;
	stm32f0_periph_segment PT_NULL;
}

SECTIONS {

	/* =========================================================================*/
	/* STM32F051 PERIPHERALS */
	/* =========================================================================*/

	apb 0x40000000 (NOLOAD): {
		. = 0x00000; KEEP(*(.bss.mmreg.tim2))
		. = 0x00400; KEEP(*(.bss.mmreg.tim3))
		. = 0x01000; KEEP(*(.bss.mmreg.tim6))
		. = 0x01400; KEEP(*(.bss.mmreg.tim7))
		. = 0x02000; KEEP(*(.bss.mmreg.tim14))
		. = 0x02800; KEEP(*(.bss.mmreg.rtc))
		. = 0x02c00; KEEP(*(.bss.mmreg.wwdg))
		. = 0x03000; KEEP(*(.bss.mmreg.iwdg))
		. = 0x03800; KEEP(*(.bss.mmreg.spi2))
		. = 0x04400; KEEP(*(.bss.mmreg.usart2))
		. = 0x04800; KEEP(*(.bss.mmreg.usart3))
		. = 0x04C00; KEEP(*(.bss.mmreg.usart4))
		. = 0x05000; KEEP(*(.bss.mmreg.usart5))
		. = 0x05400; KEEP(*(.bss.mmreg.i2c1))
		. = 0x05800; KEEP(*(.bss.mmreg.i2c2))
		. = 0x05C00; KEEP(*(.bss.mmreg.usb))
		. = 0x06000; KEEP(*(.bss.mmreg.usb_can_sram))
		. = 0x06400; KEEP(*(.bss.mmreg.can))
		. = 0x06C00; KEEP(*(.bss.mmreg.crs))
		. = 0x07000; KEEP(*(.bss.mmreg.pwr))
		. = 0x07400; KEEP(*(.bss.mmreg.dac))
		. = 0x07800; KEEP(*(.bss.mmreg.cec))
		. = 0x10000; KEEP(*(.bss.mmreg.syscfg_comp))
		. = 0x10400; KEEP(*(.bss.mmreg.exti))
		. = 0x11400; KEEP(*(.bss.mmreg.usart6))
		. = 0x11800; KEEP(*(.bss.mmreg.usart7))
		. = 0x11C00; KEEP(*(.bss.mmreg.usart8))
		. = 0x12400; KEEP(*(.bss.mmreg.adc))
		. = 0x12C00; KEEP(*(.bss.mmreg.tim1))
		. = 0x13000; KEEP(*(.bss.mmreg.spi1_i2s1))
		. = 0x13800; KEEP(*(.bss.mmreg.usart1))
		. = 0x14000; KEEP(*(.bss.mmreg.tim15))
		. = 0x14400; KEEP(*(.bss.mmreg.tim16))
		. = 0x14800; KEEP(*(.bss.mmreg.tim17))
		. = 0x15800; KEEP(*(.bss.mmreg.dbgmcu))
	} : stm32f0_periph_segment

	ahb1 0x40020000 (NOLOAD): {
		. = 0x1000; KEEP(*(.bss.mmreg.rcc))

		/*
		0x4002 0000 - 0x400203FF DMA
		0x4002 0400 - 0x400207FF DMA2
		0x4002 2000 - 0x400223FF FLASH interface
		0x4002 3000 - 0x400233FF CRC
		0x4002 4000 - 0x400243FF TSC
		*/
	} : stm32f0_periph_segment

	ahb2 0x48000000 (NOLOAD): {
		. = 0x0000; KEEP(*(.bss.mmreg.gpioa))
		. = 0x0400; KEEP(*(.bss.mmreg.gpiob))
		. = 0x0800; KEEP(*(.bss.mmreg.gpioc))
		. = 0x0C00; KEEP(*(.bss.mmreg.gpiod))
		. = 0x1000; KEEP(*(.bss.mmreg.gpioe))
		. = 0x1400; KEEP(*(.bss.mmreg.gpiof))
	} : stm32f0_periph_segment

	/* =========================================================================*/
	/* CORTEX-M0 PERIPHERALS */
	/* =========================================================================*/

	sysregs 0xE0000000 (NOLOAD): {
		. = 0xE010; KEEP(*(.bss.mmreg.systick))
		. = 0xE100; KEEP(*(.bss.mmreg.nvic))
		. = 0xED00; KEEP(*(.bss.mmreg.scb))
	} > cm0_periph_region : cm0_periph_segment

	/* =========================================================================*/
	/* CODE */
	/* =========================================================================*/

	/* The startup code goes first into FLASH */
	.initial_sp_value : ALIGN(4) {
		KEEP(*(.initial_sp_value))
		. = ALIGN(4);
	} >flash_region : text_segment

	.exception_vectors : ALIGN(4) {
		KEEP(*(.exception_vectors))
		. = ALIGN(4);
	} >flash_region : text_segment

	.interrupt_vectors : ALIGN(4) {
		KEEP(*(.interrupt_vectors))
		. = ALIGN(4);
	} >flash_region : text_segment

	/* The program code and other data goes into FLASH 

	.text : { *(.text)}
	means get all .text sections of all object files 
	and concatenate them into one .text section.

	.{section}: the basic section.
	.{section}.*: sections generated by -ffunction-sections and -fdata-sections so that each function/data has a unique section.

	*/
	.text : ALIGN(4) {
		*(.text .text*) /* Get all .text sections of all object files and concatenate them into one .text section. */
		*(.glue_7) /* glue arm to thumb code */
		*(.glue_7t) /* glue thumb to arm code */
		*(.eh_frame)

		/*
		https://blog.thea.codes/the-most-thoroughly-commented-linker-script/
		*(.text .text.* .gnu.linkonce.t.*)
		*(.rodata .rodata* .gnu.linkonce.r.*)
		*/

		KEEP (*(.init))
		KEEP (*(.fini))
		. = ALIGN(4);
	} >flash_region : text_segment

	.rodata : ALIGN(4) {
		*(.rodata .rodata*)
		. = ALIGN(4);
	} >flash_region : text_segment

	/*  .preinit_array: {
		PROVIDE_HIDDEN (__preinit_array_start = .);
		KEEP (*(.preinit_array*))
		PROVIDE_HIDDEN (__preinit_array_end = .);
	} >flash_region

	.init_array: {
		PROVIDE_HIDDEN (__init_array_start = .);
		KEEP (*(SORT(.init_array.*)))
		KEEP (*(.init_array*))
		PROVIDE_HIDDEN (__init_array_end = .);
	} >flash_region

	.fini_array : {
		PROVIDE_HIDDEN (__fini_array_start = .);
		KEEP (*(SORT(.fini_array.*)))
		KEEP (*(.fini_array*))
		PROVIDE_HIDDEN (__fini_array_end = .);
	} >flash_region
	*/

	/* =========================================================================*/
	/* ZERO-INITIALIZED DATA (BSS)
	/* =========================================================================*/

	.bss : ALIGN(16) {
		*(.bss .bss.*)
		. = ALIGN(4);
	} >sram_region : bss_segment

	_bss_start = ADDR(.bss);
	_bss_end = ADDR(.bss) + SIZEOF(.bss);

	/* =========================================================================*/
	/* MAIN STACK */
	/* =========================================================================*/

	/* Limit of the Main Stack, which is used for exception handlers and the startup code
		(i.e. before the scheduler has started). */
	_main_stack_size = 0x180;
	_main_stack_start = ADDR(main_stack);
	_main_stack_end = ADDR(main_stack) + SIZEOF(main_stack);

	main_stack : ALIGN(16) {
		. = . + _main_stack_size;
	} >sram_region : stack_segment

	/* =========================================================================*/
	/* INITIALIZED DATA
	/* =========================================================================*/

	_data_lma_start = LOADADDR(.data);

	/* Initialized data sections goes into RAM, load LMA copy after code */
	.data : ALIGN(16) {
		_data_vma_start = .;
		*(.data .data*)
		. = ALIGN(4);
		_data_vma_end = .;
	} >sram_region AT> flash_region : data_segment

}

